2025-04-29 08:49:54,857 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-29 08:49:55,151 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-29 08:50:24,237 - CatastoDB - ERROR - Errore DB specifico rilevato: GroupingError - ERRORE:  le chiamate a funzioni di aggregazione non possono essere annidate
LINE 7: ...ct_agg(COALESCE(i.classificazione, 'Non Class.'), COUNT(*)) ...
                                                             ^
QUERY:  WITH comune_base AS ( -- Seleziona il comune per assicurarsi che esista
        SELECT nome FROM comune WHERE nome = p_comune_nome LIMIT 1
    ),
    immobili_classe_agg AS ( -- CTE per calcolare separatamente il JSON degli immobili
        SELECT
            p_comune_nome AS comune_nome, -- Aggiungi comune_nome per il join
            json_object_agg(COALESCE(i.classificazione, 'Non Class.'), COUNT(*)) AS immobili_json
        FROM immobile i
        JOIN partita p ON i.partita_id = p.id
        WHERE p.comune_nome = p_comune_nome
        GROUP BY p.comune_nome -- Gruppo per comune per ottenere un JSON per comune
    ),
    stats AS ( -- CTE principale per le altre statistiche
        SELECT
            c.nome AS comune_nome,
            COUNT(DISTINCT p.id) AS totale_partite,
            COUNT(DISTINCT pos.id) AS totale_possessori,
            COUNT(DISTINCT i.id) AS totale_immobili,
            COUNT(DISTINCT CASE WHEN p.stato = 'attiva' THEN p.id END) AS partite_attive,
            COUNT(DISTINCT CASE WHEN p.stato = 'inattiva' THEN p.id END) AS partite_inattive
            -- Rimosso il calcolo di immobili_per_classe da qui
        FROM comune c
        LEFT JOIN partita p ON c.nome = p.comune_nome
        LEFT JOIN partita_possessore pp ON p.id = pp.partita_id
        LEFT JOIN possessore pos ON pp.possessore_id = pos.id
        LEFT JOIN immobile i ON p.id = i.partita_id
        WHERE c.nome = p_comune_nome
        GROUP BY c.nome
    )
    -- Join finale per combinare i risultati
    SELECT
        cb.nome AS comune,
        COALESCE(s.totale_partite, 0) AS totale_partite,
        COALESCE(s.totale_possessori, 0) AS totale_possessori,
        COALESCE(s.totale_immobili, 0) AS totale_immobili,
        COALESCE(s.partite_attive, 0) AS partite_attive,
        COALESCE(s.partite_inattive, 0) AS partite_inattive,
        ica.immobili_json AS immobili_per_classe, -- Prendi il JSON dalla CTE separata
        CASE
            WHEN COALESCE(s.totale_partite, 0) = 0 THEN 0
            ELSE COALESCE(s.totale_possessori, 0)::NUMERIC / s.totale_partite
        END AS possessori_per_partita
    FROM comune_base cb
    LEFT JOIN stats s ON cb.nome = s.comune_nome
    LEFT JOIN immobili_classe_agg ica ON cb.nome = ica.comune_nome
CONTEXT:  funzione PL/pgSQL genera_report_comune(character varying) riga 3 a RETURN QUERY

2025-04-29 08:50:24,239 - CatastoDB - ERROR - SQLSTATE: 42803
2025-04-29 08:50:24,239 - CatastoDB - ERROR - Query renderizzata: b"SELECT * FROM genera_report_comune('carcare')"
2025-04-29 08:50:24,239 - CatastoDB - INFO - Rollback eseguito.
2025-04-29 08:50:24,240 - CatastoDB - ERROR - Errore DB get_report_comune: ERRORE:  le chiamate a funzioni di aggregazione non possono essere annidate
LINE 7: ...ct_agg(COALESCE(i.classificazione, 'Non Class.'), COUNT(*)) ...
                                                             ^
QUERY:  WITH comune_base AS ( -- Seleziona il comune per assicurarsi che esista
        SELECT nome FROM comune WHERE nome = p_comune_nome LIMIT 1
    ),
    immobili_classe_agg AS ( -- CTE per calcolare separatamente il JSON degli immobili
        SELECT
            p_comune_nome AS comune_nome, -- Aggiungi comune_nome per il join
            json_object_agg(COALESCE(i.classificazione, 'Non Class.'), COUNT(*)) AS immobili_json
        FROM immobile i
        JOIN partita p ON i.partita_id = p.id
        WHERE p.comune_nome = p_comune_nome
        GROUP BY p.comune_nome -- Gruppo per comune per ottenere un JSON per comune
    ),
    stats AS ( -- CTE principale per le altre statistiche
        SELECT
            c.nome AS comune_nome,
            COUNT(DISTINCT p.id) AS totale_partite,
            COUNT(DISTINCT pos.id) AS totale_possessori,
            COUNT(DISTINCT i.id) AS totale_immobili,
            COUNT(DISTINCT CASE WHEN p.stato = 'attiva' THEN p.id END) AS partite_attive,
            COUNT(DISTINCT CASE WHEN p.stato = 'inattiva' THEN p.id END) AS partite_inattive
            -- Rimosso il calcolo di immobili_per_classe da qui
        FROM comune c
        LEFT JOIN partita p ON c.nome = p.comune_nome
        LEFT JOIN partita_possessore pp ON p.id = pp.partita_id
        LEFT JOIN possessore pos ON pp.possessore_id = pos.id
        LEFT JOIN immobile i ON p.id = i.partita_id
        WHERE c.nome = p_comune_nome
        GROUP BY c.nome
    )
    -- Join finale per combinare i risultati
    SELECT
        cb.nome AS comune,
        COALESCE(s.totale_partite, 0) AS totale_partite,
        COALESCE(s.totale_possessori, 0) AS totale_possessori,
        COALESCE(s.totale_immobili, 0) AS totale_immobili,
        COALESCE(s.partite_attive, 0) AS partite_attive,
        COALESCE(s.partite_inattive, 0) AS partite_inattive,
        ica.immobili_json AS immobili_per_classe, -- Prendi il JSON dalla CTE separata
        CASE
            WHEN COALESCE(s.totale_partite, 0) = 0 THEN 0
            ELSE COALESCE(s.totale_possessori, 0)::NUMERIC / s.totale_partite
        END AS possessori_per_partita
    FROM comune_base cb
    LEFT JOIN stats s ON cb.nome = s.comune_nome
    LEFT JOIN immobili_classe_agg ica ON cb.nome = ica.comune_nome
CONTEXT:  funzione PL/pgSQL genera_report_comune(character varying) riga 3 a RETURN QUERY

2025-04-29 08:50:31,211 - CatastoDB - ERROR - Errore DB specifico rilevato: GroupingError - ERRORE:  le chiamate a funzioni di aggregazione non possono essere annidate
LINE 7: ...ct_agg(COALESCE(i.classificazione, 'Non Class.'), COUNT(*)) ...
                                                             ^
QUERY:  WITH comune_base AS ( -- Seleziona il comune per assicurarsi che esista
        SELECT nome FROM comune WHERE nome = p_comune_nome LIMIT 1
    ),
    immobili_classe_agg AS ( -- CTE per calcolare separatamente il JSON degli immobili
        SELECT
            p_comune_nome AS comune_nome, -- Aggiungi comune_nome per il join
            json_object_agg(COALESCE(i.classificazione, 'Non Class.'), COUNT(*)) AS immobili_json
        FROM immobile i
        JOIN partita p ON i.partita_id = p.id
        WHERE p.comune_nome = p_comune_nome
        GROUP BY p.comune_nome -- Gruppo per comune per ottenere un JSON per comune
    ),
    stats AS ( -- CTE principale per le altre statistiche
        SELECT
            c.nome AS comune_nome,
            COUNT(DISTINCT p.id) AS totale_partite,
            COUNT(DISTINCT pos.id) AS totale_possessori,
            COUNT(DISTINCT i.id) AS totale_immobili,
            COUNT(DISTINCT CASE WHEN p.stato = 'attiva' THEN p.id END) AS partite_attive,
            COUNT(DISTINCT CASE WHEN p.stato = 'inattiva' THEN p.id END) AS partite_inattive
            -- Rimosso il calcolo di immobili_per_classe da qui
        FROM comune c
        LEFT JOIN partita p ON c.nome = p.comune_nome
        LEFT JOIN partita_possessore pp ON p.id = pp.partita_id
        LEFT JOIN possessore pos ON pp.possessore_id = pos.id
        LEFT JOIN immobile i ON p.id = i.partita_id
        WHERE c.nome = p_comune_nome
        GROUP BY c.nome
    )
    -- Join finale per combinare i risultati
    SELECT
        cb.nome AS comune,
        COALESCE(s.totale_partite, 0) AS totale_partite,
        COALESCE(s.totale_possessori, 0) AS totale_possessori,
        COALESCE(s.totale_immobili, 0) AS totale_immobili,
        COALESCE(s.partite_attive, 0) AS partite_attive,
        COALESCE(s.partite_inattive, 0) AS partite_inattive,
        ica.immobili_json AS immobili_per_classe, -- Prendi il JSON dalla CTE separata
        CASE
            WHEN COALESCE(s.totale_partite, 0) = 0 THEN 0
            ELSE COALESCE(s.totale_possessori, 0)::NUMERIC / s.totale_partite
        END AS possessori_per_partita
    FROM comune_base cb
    LEFT JOIN stats s ON cb.nome = s.comune_nome
    LEFT JOIN immobili_classe_agg ica ON cb.nome = ica.comune_nome
CONTEXT:  funzione PL/pgSQL genera_report_comune(character varying) riga 3 a RETURN QUERY

2025-04-29 08:50:31,212 - CatastoDB - ERROR - SQLSTATE: 42803
2025-04-29 08:50:31,213 - CatastoDB - ERROR - Query renderizzata: b"SELECT * FROM genera_report_comune('Carcare')"
2025-04-29 08:50:31,214 - CatastoDB - INFO - Rollback eseguito.
2025-04-29 08:50:31,214 - CatastoDB - ERROR - Errore DB get_report_comune: ERRORE:  le chiamate a funzioni di aggregazione non possono essere annidate
LINE 7: ...ct_agg(COALESCE(i.classificazione, 'Non Class.'), COUNT(*)) ...
                                                             ^
QUERY:  WITH comune_base AS ( -- Seleziona il comune per assicurarsi che esista
        SELECT nome FROM comune WHERE nome = p_comune_nome LIMIT 1
    ),
    immobili_classe_agg AS ( -- CTE per calcolare separatamente il JSON degli immobili
        SELECT
            p_comune_nome AS comune_nome, -- Aggiungi comune_nome per il join
            json_object_agg(COALESCE(i.classificazione, 'Non Class.'), COUNT(*)) AS immobili_json
        FROM immobile i
        JOIN partita p ON i.partita_id = p.id
        WHERE p.comune_nome = p_comune_nome
        GROUP BY p.comune_nome -- Gruppo per comune per ottenere un JSON per comune
    ),
    stats AS ( -- CTE principale per le altre statistiche
        SELECT
            c.nome AS comune_nome,
            COUNT(DISTINCT p.id) AS totale_partite,
            COUNT(DISTINCT pos.id) AS totale_possessori,
            COUNT(DISTINCT i.id) AS totale_immobili,
            COUNT(DISTINCT CASE WHEN p.stato = 'attiva' THEN p.id END) AS partite_attive,
            COUNT(DISTINCT CASE WHEN p.stato = 'inattiva' THEN p.id END) AS partite_inattive
            -- Rimosso il calcolo di immobili_per_classe da qui
        FROM comune c
        LEFT JOIN partita p ON c.nome = p.comune_nome
        LEFT JOIN partita_possessore pp ON p.id = pp.partita_id
        LEFT JOIN possessore pos ON pp.possessore_id = pos.id
        LEFT JOIN immobile i ON p.id = i.partita_id
        WHERE c.nome = p_comune_nome
        GROUP BY c.nome
    )
    -- Join finale per combinare i risultati
    SELECT
        cb.nome AS comune,
        COALESCE(s.totale_partite, 0) AS totale_partite,
        COALESCE(s.totale_possessori, 0) AS totale_possessori,
        COALESCE(s.totale_immobili, 0) AS totale_immobili,
        COALESCE(s.partite_attive, 0) AS partite_attive,
        COALESCE(s.partite_inattive, 0) AS partite_inattive,
        ica.immobili_json AS immobili_per_classe, -- Prendi il JSON dalla CTE separata
        CASE
            WHEN COALESCE(s.totale_partite, 0) = 0 THEN 0
            ELSE COALESCE(s.totale_possessori, 0)::NUMERIC / s.totale_partite
        END AS possessori_per_partita
    FROM comune_base cb
    LEFT JOIN stats s ON cb.nome = s.comune_nome
    LEFT JOIN immobili_classe_agg ica ON cb.nome = ica.comune_nome
CONTEXT:  funzione PL/pgSQL genera_report_comune(character varying) riga 3 a RETURN QUERY

2025-04-29 08:56:18,107 - CatastoDB - INFO - Disconnessione completata
2025-04-29 08:57:08,442 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-29 08:57:08,531 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-29 08:57:38,924 - CatastoDB - INFO - Disconnessione completata
2025-04-29 10:07:34,664 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-29 10:07:34,811 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-29 10:08:19,606 - CatastoDB - INFO - Disconnessione completata
2025-04-29 10:18:41,487 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-29 10:18:41,581 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-29 10:19:53,187 - CatastoDB - ERROR - Errore DB specifico rilevato: UndefinedFunction - ERRORE:  la funzione ricerca_avanzata_possessori(unknown) non esiste
LINE 1: SELECT * FROM ricerca_avanzata_possessori('cognome')
                      ^
HINT:  Nessuna funzione trovata con nome e tipi di argomenti forniti. Potrebbe essere necessario convertire i tipi esplicitamente.

2025-04-29 10:19:53,188 - CatastoDB - ERROR - SQLSTATE: 42883
2025-04-29 10:19:53,188 - CatastoDB - ERROR - Query renderizzata: b"SELECT * FROM ricerca_avanzata_possessori('cognome')"
2025-04-29 10:19:53,189 - CatastoDB - INFO - Rollback eseguito.
2025-04-29 10:19:53,189 - CatastoDB - WARNING - Funzione 'ricerca_avanzata_possessori' non trovata nel database.
2025-04-29 10:31:59,271 - CatastoDB - ERROR - Errore DB specifico rilevato: UndefinedFunction - ERRORE:  la funzione ricerca_avanzata_possessori(unknown) non esiste
LINE 1: SELECT * FROM ricerca_avanzata_possessori('cognome')
                      ^
HINT:  Nessuna funzione trovata con nome e tipi di argomenti forniti. Potrebbe essere necessario convertire i tipi esplicitamente.

2025-04-29 10:31:59,271 - CatastoDB - ERROR - SQLSTATE: 42883
2025-04-29 10:31:59,272 - CatastoDB - ERROR - Query renderizzata: b"SELECT * FROM ricerca_avanzata_possessori('cognome')"
2025-04-29 10:31:59,273 - CatastoDB - INFO - Rollback eseguito.
2025-04-29 10:31:59,273 - CatastoDB - WARNING - Funzione 'ricerca_avanzata_possessori' non trovata nel database.
2025-04-29 10:37:14,390 - CatastoDB - INFO - Disconnessione completata
2025-04-29 10:41:45,945 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico schema catasto
2025-04-29 10:41:46,019 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-29 10:49:58,047 - CatastoDB - ERROR - Errore DB specifico rilevato: UndefinedColumn - ERRORE:  il record "new" non ha un campo "id"
CONTEXT:  Assegnazione PL/pgSQL "v_record_id := NEW.id"
funzione PL/pgSQL audit_trigger_function() riga 23 a assegnazione

2025-04-29 10:49:58,048 - CatastoDB - ERROR - SQLSTATE: 42703
2025-04-29 10:49:58,048 - CatastoDB - ERROR - Query renderizzata: b"INSERT INTO comune (nome, provincia, regione, periodo_id) VALUES ('Savona', 'Savona', 'Liguria', 1) ON CONFLICT (nome) DO NOTHING"
2025-04-29 10:49:58,049 - CatastoDB - INFO - Rollback eseguito.
2025-04-29 10:49:58,049 - __main__ - ERROR - Errore non gestito nel menu principale: ERRORE:  il record "new" non ha un campo "id"
CONTEXT:  Assegnazione PL/pgSQL "v_record_id := NEW.id"
funzione PL/pgSQL audit_trigger_function() riga 23 a assegnazione
Traceback (most recent call last):
  File "C:\Users\saint\catasto\gemini\python_example.py", line 1774, in main
    menu_principale(db)
    ~~~~~~~~~~~~~~~^^^^
  File "C:\Users\saint\catasto\gemini\python_example.py", line 316, in menu_principale
    elif scelta == "2": menu_inserimento(db)
                        ~~~~~~~~~~~~~~~~^^^^
  File "C:\Users\saint\catasto\gemini\python_example.py", line 595, in menu_inserimento
    if scelta == "1": aggiungi_comune(db)
                      ~~~~~~~~~~~~~~~^^^^
  File "C:\Users\saint\catasto\gemini\python_example.py", line 224, in aggiungi_comune
    if db.execute_query(query, (nome, provincia, regione, periodo_id)):
       ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\saint\catasto\gemini\catasto_db_manager.py", line 178, in execute_query
    raise db_err # RILANCIA l'eccezione per gestione specifica nel chiamante
    ^^^^^^^^^^^^
  File "C:\Users\saint\catasto\gemini\catasto_db_manager.py", line 151, in execute_query
    self.cur.execute(query, params)
    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
  File "C:\Users\saint\AppData\Local\Programs\Python\Python313\Lib\site-packages\psycopg2\extras.py", line 146, in execute
    return super().execute(query, vars)
           ~~~~~~~~~~~~~~~^^^^^^^^^^^^^
psycopg2.errors.UndefinedColumn: ERRORE:  il record "new" non ha un campo "id"
CONTEXT:  Assegnazione PL/pgSQL "v_record_id := NEW.id"
funzione PL/pgSQL audit_trigger_function() riga 23 a assegnazione

2025-04-29 10:49:58,102 - CatastoDB - INFO - Disconnessione completata
2025-04-29 12:00:37,407 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico (schema: catasto)
2025-04-29 12:00:37,512 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-29 12:00:42,148 - CatastoDB - ERROR - Errore DB specifico rilevato: UndefinedColumn - ERRORE:  la colonna "id" non esiste
LINE 1: SELECT id, nome, provincia, regione FROM comune ORDER BY nom...
               ^

2025-04-29 12:00:42,149 - CatastoDB - ERROR - SQLSTATE: 42703
2025-04-29 12:00:42,149 - CatastoDB - ERROR - Query renderizzata: b'SELECT id, nome, provincia, regione FROM comune ORDER BY nome'
2025-04-29 12:00:42,150 - CatastoDB - INFO - Rollback eseguito.
2025-04-29 12:00:42,151 - CatastoDB - ERROR - Errore DB in get_comuni: ERRORE:  la colonna "id" non esiste
LINE 1: SELECT id, nome, provincia, regione FROM comune ORDER BY nom...
               ^

2025-04-29 12:04:25,912 - CatastoDB - ERROR - Errore di connessione DB: server closed the connection unexpectedly
	This probably means the server terminated abnormally
	before or while processing the request.

2025-04-29 12:04:25,925 - CatastoDB - INFO - Disconnessione completata
2025-04-29 12:04:25,926 - CatastoDB - INFO - Riconnessione in corso...
2025-04-29 12:04:25,926 - CatastoDB - ERROR - Riconnessione fallita definitivamente.
2025-04-29 12:04:25,927 - CatastoDB - INFO - Disconnessione completata
2025-04-29 14:37:43,741 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico (schema: catasto)
2025-04-29 14:37:43,825 - CatastoDB - ERROR - Errore operativo durante la connessione (controllare DB e parametri): connection to server at "localhost" (::1), port 5432 failed: FATALE:  il database "catasto_storico" non esiste

2025-04-29 16:36:38,958 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico (schema: catasto)
2025-04-29 16:36:39,203 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-29 16:36:44,177 - CatastoDB - ERROR - Errore DB specifico rilevato: UndefinedColumn - ERRORE:  la colonna "id" non esiste
LINE 1: SELECT id, nome, provincia, regione FROM comune ORDER BY nom...
               ^

2025-04-29 16:36:44,182 - CatastoDB - ERROR - SQLSTATE: 42703
2025-04-29 16:36:44,187 - CatastoDB - ERROR - Query renderizzata: b'SELECT id, nome, provincia, regione FROM comune ORDER BY nome'
2025-04-29 16:36:44,192 - CatastoDB - INFO - Rollback eseguito.
2025-04-29 16:36:44,196 - CatastoDB - ERROR - Errore DB in get_comuni: ERRORE:  la colonna "id" non esiste
LINE 1: SELECT id, nome, provincia, regione FROM comune ORDER BY nom...
               ^

2025-04-29 16:36:55,974 - CatastoDB - ERROR - Errore DB specifico rilevato: UndefinedColumn - ERRORE:  la colonna "id" non esiste
LINE 1: SELECT id, nome, provincia, regione FROM comune ORDER BY nom...
               ^

2025-04-29 16:36:55,979 - CatastoDB - ERROR - SQLSTATE: 42703
2025-04-29 16:36:55,984 - CatastoDB - ERROR - Query renderizzata: b'SELECT id, nome, provincia, regione FROM comune ORDER BY nome'
2025-04-29 16:36:55,989 - CatastoDB - INFO - Rollback eseguito.
2025-04-29 16:36:55,994 - CatastoDB - ERROR - Errore DB in get_comuni: ERRORE:  la colonna "id" non esiste
LINE 1: SELECT id, nome, provincia, regione FROM comune ORDER BY nom...
               ^

2025-04-29 16:37:06,831 - CatastoDB - INFO - Disconnessione completata
2025-04-29 16:37:55,651 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico (schema: catasto)
2025-04-29 16:37:55,878 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-29 16:38:11,480 - CatastoDB - ERROR - Errore DB specifico rilevato: UndefinedColumn - ERRORE:  la colonna "id" non esiste
LINE 1: SELECT id, nome, provincia, regione FROM comune ORDER BY nom...
               ^

2025-04-29 16:38:11,485 - CatastoDB - ERROR - SQLSTATE: 42703
2025-04-29 16:38:11,490 - CatastoDB - ERROR - Query renderizzata: b'SELECT id, nome, provincia, regione FROM comune ORDER BY nome'
2025-04-29 16:38:11,495 - CatastoDB - INFO - Rollback eseguito.
2025-04-29 16:38:11,500 - CatastoDB - ERROR - Errore DB in get_comuni: ERRORE:  la colonna "id" non esiste
LINE 1: SELECT id, nome, provincia, regione FROM comune ORDER BY nom...
               ^

2025-04-29 16:40:45,591 - CatastoDB - INFO - Disconnessione completata
2025-04-29 16:48:22,710 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico (schema: catasto)
2025-04-29 16:48:22,946 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-29 16:48:28,197 - CatastoDB - ERROR - Errore DB specifico rilevato: UndefinedColumn - ERRORE:  la colonna "id" non esiste
LINE 1: SELECT id, nome, provincia, regione FROM comune ORDER BY nom...
               ^

2025-04-29 16:48:28,202 - CatastoDB - ERROR - SQLSTATE: 42703
2025-04-29 16:48:28,207 - CatastoDB - ERROR - Query renderizzata: b'SELECT id, nome, provincia, regione FROM comune ORDER BY nome'
2025-04-29 16:48:28,212 - CatastoDB - INFO - Rollback eseguito.
2025-04-29 16:48:28,217 - CatastoDB - ERROR - Errore DB in get_comuni: ERRORE:  la colonna "id" non esiste
LINE 1: SELECT id, nome, provincia, regione FROM comune ORDER BY nom...
               ^

2025-04-29 16:53:06,287 - CatastoDB - INFO - Disconnessione completata
2025-04-29 17:35:00,970 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico (schema: catasto)
2025-04-29 17:35:01,107 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-29 17:35:27,679 - CatastoDB - INFO - Disconnessione completata
2025-04-29 19:07:51,868 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico (schema: catasto)
2025-04-29 19:07:51,971 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-29 19:07:56,671 - CatastoDB - ERROR - Errore DB specifico rilevato: UndefinedColumn - ERRORE:  la colonna "id" non esiste
LINE 1: SELECT id, nome, provincia, regione FROM comune ORDER BY nom...
               ^

2025-04-29 19:07:56,672 - CatastoDB - ERROR - SQLSTATE: 42703
2025-04-29 19:07:56,672 - CatastoDB - ERROR - Query renderizzata: b'SELECT id, nome, provincia, regione FROM comune ORDER BY nome'
2025-04-29 19:07:56,673 - CatastoDB - INFO - Rollback eseguito.
2025-04-29 19:07:56,674 - CatastoDB - ERROR - Errore DB in get_comuni: ERRORE:  la colonna "id" non esiste
LINE 1: SELECT id, nome, provincia, regione FROM comune ORDER BY nom...
               ^

2025-04-29 19:08:07,075 - CatastoDB - INFO - Disconnessione completata
2025-04-29 19:16:38,965 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico (schema: catasto)
2025-04-29 19:16:39,074 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-29 19:16:42,546 - CatastoDB - ERROR - Errore DB specifico rilevato: UndefinedColumn - ERRORE:  la colonna "id" non esiste
LINE 1: SELECT id, nome, provincia, regione FROM comune ORDER BY nom...
               ^

2025-04-29 19:16:42,547 - CatastoDB - ERROR - SQLSTATE: 42703
2025-04-29 19:16:42,547 - CatastoDB - ERROR - Query renderizzata: b'SELECT id, nome, provincia, regione FROM comune ORDER BY nome'
2025-04-29 19:16:42,548 - CatastoDB - INFO - Rollback eseguito.
2025-04-29 19:16:42,549 - CatastoDB - ERROR - Errore DB in get_comuni: ERRORE:  la colonna "id" non esiste
LINE 1: SELECT id, nome, provincia, regione FROM comune ORDER BY nom...
               ^

2025-04-29 19:16:58,895 - CatastoDB - INFO - Disconnessione completata
2025-04-29 19:25:54,799 - CatastoDB - INFO - Inizializzato gestore per database catasto_storico (schema: catasto)
2025-04-29 19:25:54,867 - CatastoDB - INFO - Connessione stabilita con successo
2025-04-29 19:26:14,334 - CatastoDB - INFO - Disconnessione completata
